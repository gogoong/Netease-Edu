<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
    <title>JS类的继承</title>
</head>

<body>
  <!-- 类式继承-->
  <script type="text/javascript">
  //先声明一个超类
  // var Animal = function(name) {
  //     this.name = name;
  //   }
  //   //给这个超类的原型对象上添加方法
  // Animal.prototype.Eat = function() {
  //   console.log(this.name + " Eat");
  // };
  // // Animal.prototype = {
  // // 	run:function(){this.name + "run"}
  // // };
  // 	 Animal.prototype.Run = function(){this.name+ "run"}
  // //实例化这个超
  // // var a = new Animal("Animal");
  // //再创建构造函数对象类
  // var Cat = function(name, sex) {
  //     //这个类中要调用超类Animal的构造函数，并将参数name传给它
  //     Animal.call(this, name);
  //     this.sex = sex;
  //   }
  //   //这个子类的原型对象等于超类的实例
  // // Cat.prototype = new Animal();
  // //因为子类的原型对象等于超类的实例，所以prototype.constructor这个方法也等于超类构造函数
  // console.log(Cat.prototype.constructor);
  // //这个是Animal超类的引用，所以要从新赋值为自己本身
  // // Cat.prototype.constructor = Cat;
  // // console.log(Cat.prototype.constructor);
  // //子类本身添加了getSex 方法
  // Cat.prototype.getSex = function() {
  //     return this.sex;
  //   }
  //   //实例化这个子类
  // var _m = new Animal("cat");
  // //自身的方法
  // // console.log(_m.getSex()); //male
  // //继承超类的方法
  // console.log(_m.Eat()); //cat
  		// var Car = {
  		// 	name : "chezi",
  		// 	run:function(){console.log(this.logo + "run")}
  		// };
  		var Car = function(name){
  			this.name = name;
  			function run(){console.log(this.name + "run")}
  		};
  		Car.prototype = {start:function(){console.log(this.name + " start")},
  						 run:function(){console.log(this.name+ " run")}	
  						};
  		// var baoma = Object.create(Car);
  		var baoma = new Car('baoma');
  		baoma.run();
  		baoma.start();
  </script>
</body>

</html>